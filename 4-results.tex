	\section{Получение и первичная обработка данных}
	
	\begin{wrapfigure}[13]{r}{0.5\textwidth}
\vspace{-12px}
  \begin{center}
    \includegraphics[width=0.4\textwidth]{fig/obj.png}
    \vspace{3px}
    \caption{Изображение с 2D-детектора}
    \label{fig:difractogram}
  \end{center}
\end{wrapfigure}
	
	
	\paragraph{Калибровка}
На рис. \ref{fig:difractogram} можно увидеть типичную дифрактограмму, полученную в сканирующем эксперименте. 

Калибровка и азимутальное интегрирование производилось с помощью библиотеки pyFAI, \cite{pyfai}.

\paragraph{Интегрирование}

После азимутального интегрирования получаются такие пики (рис. \ref{fig:azim} в диапазоне $\Theta$ от ?? до ?? градусов. 

\begin{figure}[t]
    \centering
    \includegraphics[width=\linewidth]{fig/azim.png}
    \caption{Азимутальное интегрирование}
    \label{fig:azim}
\end{figure}


	\section{Вычитание фона, аппроксимация пиков}
	Стандартные алгоритмы для автоматического распознавания фона, основанные на полиномиальной аппроксимации, показали себя не продуктивными в нашем случае. Распознавание кристаллических пиков и аморфного фона производилось с помощью нелинейного фильтра "rolling ball". В рентгеноструктурном анализе он как правило применяется к двумерным дифрактограммам кристаллических материалов, как например, в работе \cite{ball2018}. Однако подходящая реализация для одномерных профилей, необходимая в случае дифракции на полимерах, не представлена в открытых источниках. Ниже (листинг \ref{lst:ball}) приведена реализация алгоритма для одномерных профилей на языке Python. 
	Идеи для простой реализцаа позаимствованы из работы \cite{ball-code},  
	
	Принцип действия алгоритма понятен из рис. \ref{fig:ball}. 
	
	\begin{figure}[h]
	    \centering
	    \includegraphics[width=\linewidth]{fig/ball.PNG}
	    \caption{Caption}
	    \label{fig:ball}
	\end{figure}
	  
	
	\begin{lstlisting}[language=Python, caption=Python example, label={lst:ball}]
	
import numpy as np
 
def incmatrix(genl1,genl2):
    m = len(genl1)
    n = len(genl2)
    M = None #to become the incidence matrix
    VT = np.zeros((n*m,1), int)  #dummy variable
 
    #compute the bitwise xor matrix
    M1 = bitxormatrix(genl1)
    M2 = np.triu(bitxormatrix(genl2),1) 
 
    for i in range(m-1):
        for j in range(i+1, m):
            [r,c] = np.where(M2 == M1[i,j])
            for k in range(len(r)):
                VT[(i)*n + r[k]] = 1;
                VT[(i)*n + c[k]] = 1;
                VT[(j)*n + r[k]] = 1;
                VT[(j)*n + c[k]] = 1;
 
                if M is None:
                    M = np.copy(VT)
                else:
                    M = np.concatenate((M, VT), 1)
 
                VT = np.zeros((n*m,1), int)
 
    return M
\end{lstlisting}
	
	\section{Карты кристалличности}
	
	\section{Параметры решетки, расчеты}
	
	
	\paragraph{Rolling-ball}
	погрешности, чем хорошо, почему он, какие еще бывают
	


    \paragraph{фиттинг}

\begin{figure}
    \centering
    \includegraphics[width=\linewidth]{fig/gauss-fit.png}
    \caption{Аппроксимация формы пика по разным моделям}
    \label{fig:my_label}
\end{figure}
	
	\paragraph{Карты кристалличности}
	
	\begin{figure}[ht]\center
\begin{tabular}{cc}
\includegraphics[width=0.5\linewidth]{fig/map-1.png}
&
\includegraphics[width=0.5\linewidth]{fig/map-2.png} \\
\includegraphics[width=0.5\linewidth]{fig/map-1.png}
&
\includegraphics[width=0.5\linewidth]{fig/map-2.png}
\end{tabular}
\caption{Карты кристалличности}
\end{figure}
	
	

	
	
	
	Свойства и результаты прочих исследований:
	[Vaganov corrected]